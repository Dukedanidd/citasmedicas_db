{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///home/senorbuen0/ISC/sem6/bd/proyecto/citasmedicas_db/app/api/agenda/%5BdoctorId%5D/%5Bfecha%5D/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport mysql from 'mysql2/promise'\n\n// Configuración de la base de datos\nconst dbConfig = {\n  host: process.env.DB_HOST || 'localhost',\n  user: process.env.DB_USER || 'root',\n  password: process.env.DB_PASSWORD || '',\n  database: process.env.DB_NAME || 'clinica_db'\n}\n\n// Exportación nombrada para el método GET\nexport const GET = async (\n  request: Request,\n  { params }: { params: { doctorId: string; fecha: string } }\n) => {\n  console.log('[GET /api/agenda/[doctorId]/[fecha]] Iniciando petición...')\n  let conn\n  try {\n    const { doctorId, fecha } = params\n    console.log('[GET /api/agenda/[doctorId]/[fecha]] Parámetros:', { doctorId, fecha })\n\n    // Validar parámetros\n    if (!doctorId || !fecha) {\n      return NextResponse.json(\n        { error: 'Se requieren doctorId y fecha' },\n        { status: 400 }\n      )\n    }\n\n    // Validar formato de fecha (YYYY-MM-DD)\n    const fechaRegex = /^\\d{4}-\\d{2}-\\d{2}$/\n    if (!fechaRegex.test(fecha)) {\n      return NextResponse.json(\n        { error: 'Formato de fecha inválido. Use YYYY-MM-DD' },\n        { status: 400 }\n      )\n    }\n\n    console.log('[GET /api/agenda/[doctorId]/[fecha]] Conectando a la base de datos...')\n    conn = await mysql.createConnection(dbConfig)\n    console.log('[GET /api/agenda/[doctorId]/[fecha]] Conexión exitosa')\n\n    // Asignar current_user_id para los triggers\n    await conn.execute('SET @current_user_id = 1')\n    console.log('[GET /api/agenda/[doctorId]/[fecha]] current_user_id asignado')\n\n    // Consultar la información del doctor\n    console.log('[GET /api/agenda/[doctorId]/[fecha]] Ejecutando consulta...')\n    const [rows] = await conn.execute(\n      `SELECT u.primer_nombre as doctor_nombre,\n              u.apellido_paterno as doctor_apellido,\n              m.especialidad\n       FROM usuarios u\n       JOIN medicos m ON u.user_id = m.doctor_id\n       WHERE m.doctor_id = ?`,\n      [doctorId]\n    )\n    console.log('[GET /api/agenda/[doctorId]/[fecha]] Resultados:', rows)\n\n    if (!rows[0]) {\n      return NextResponse.json(\n        { \n          error: 'Doctor no encontrado',\n          message: 'No existe un doctor con ese ID'\n        },\n        { status: 404 }\n      )\n    }\n\n    // Validar que la fecha no sea en el pasado\n    const fechaActual = new Date()\n    const fechaAgenda = new Date(fecha)\n    if (fechaAgenda < fechaActual) {\n      return NextResponse.json(\n        { \n          error: 'Fecha inválida',\n          message: 'No se pueden programar citas en fechas pasadas'\n        },\n        { status: 400 }\n      )\n    }\n\n    // Retornar horario fijo de 8:00 a 20:00\n    const response = {\n      ...rows[0],\n      fecha: fecha,\n      hora_inicio: '08:00:00',\n      hora_fin: '20:00:00',\n      disponible: true\n    }\n\n    return NextResponse.json(response)\n  } catch (error) {\n    console.error('[GET /api/agenda/[doctorId]/[fecha]] Error:', error)\n    console.error('[GET /api/agenda/[doctorId]/[fecha]] Stack trace:', error.stack)\n    return NextResponse.json(\n      { error: 'Error al obtener la agenda' },\n      { status: 500 }\n    )\n  } finally {\n    if (conn) {\n      await conn.end()\n      console.log('[GET /api/agenda/[doctorId]/[fecha]] Conexión cerrada')\n    }\n  }\n} "],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,oCAAoC;AACpC,MAAM,WAAW;IACf,MAAM,QAAQ,GAAG,CAAC,OAAO,IAAI;IAC7B,MAAM,QAAQ,GAAG,CAAC,OAAO,IAAI;IAC7B,UAAU,QAAQ,GAAG,CAAC,WAAW,IAAI;IACrC,UAAU,QAAQ,GAAG,CAAC,OAAO,IAAI;AACnC;AAGO,MAAM,MAAM,OACjB,SACA,EAAE,MAAM,EAAmD;IAE3D,QAAQ,GAAG,CAAC;IACZ,IAAI;IACJ,IAAI;QACF,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG;QAC5B,QAAQ,GAAG,CAAC,oDAAoD;YAAE;YAAU;QAAM;QAElF,qBAAqB;QACrB,IAAI,CAAC,YAAY,CAAC,OAAO;YACvB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAgC,GACzC;gBAAE,QAAQ;YAAI;QAElB;QAEA,wCAAwC;QACxC,MAAM,aAAa;QACnB,IAAI,CAAC,WAAW,IAAI,CAAC,QAAQ;YAC3B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4C,GACrD;gBAAE,QAAQ;YAAI;QAElB;QAEA,QAAQ,GAAG,CAAC;QACZ,OAAO,MAAM,mIAAA,CAAA,UAAK,CAAC,gBAAgB,CAAC;QACpC,QAAQ,GAAG,CAAC;QAEZ,4CAA4C;QAC5C,MAAM,KAAK,OAAO,CAAC;QACnB,QAAQ,GAAG,CAAC;QAEZ,sCAAsC;QACtC,QAAQ,GAAG,CAAC;QACZ,MAAM,CAAC,KAAK,GAAG,MAAM,KAAK,OAAO,CAC/B,CAAC;;;;;4BAKqB,CAAC,EACvB;YAAC;SAAS;QAEZ,QAAQ,GAAG,CAAC,oDAAoD;QAEhE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE;YACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBACE,OAAO;gBACP,SAAS;YACX,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,2CAA2C;QAC3C,MAAM,cAAc,IAAI;QACxB,MAAM,cAAc,IAAI,KAAK;QAC7B,IAAI,cAAc,aAAa;YAC7B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBACE,OAAO;gBACP,SAAS;YACX,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,wCAAwC;QACxC,MAAM,WAAW;YACf,GAAG,IAAI,CAAC,EAAE;YACV,OAAO;YACP,aAAa;YACb,UAAU;YACV,YAAY;QACd;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+CAA+C;QAC7D,QAAQ,KAAK,CAAC,qDAAqD,MAAM,KAAK;QAC9E,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA6B,GACtC;YAAE,QAAQ;QAAI;IAElB,SAAU;QACR,IAAI,MAAM;YACR,MAAM,KAAK,GAAG;YACd,QAAQ,GAAG,CAAC;QACd;IACF;AACF"}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}